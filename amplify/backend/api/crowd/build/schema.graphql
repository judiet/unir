type Author {
  id: ID!
  name: String
  avatarUrl: String
  email: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  username: String
}

type Surveys {
  id: ID!
  title: String
  authorId: ID!
  author: Author
  surveyCreatedAt: String
  surveyUrl: String
  status: SurveyStatus
  participants(participantID: ModelIDKeyConditionInput, filter: ModelSurveyUserFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelSurveyUserConnection
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  username: String
}

enum SurveyStatus {
  DONE
  ASSIGNED
  IN_PROGRESS
}

type SurveyUser {
  id: ID!
  surveyID: ID!
  participantID: ID!
  survey: Surveys!
  participant: User!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type User {
  id: ID!
  username: String!
  email: String!
  surveys(surveyID: ModelIDKeyConditionInput, filter: ModelSurveyUserFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelSurveyUserConnection
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelAuthorConnection {
  items: [Author]
  nextToken: String
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

input ModelAuthorFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  avatarUrl: ModelStringInput
  email: ModelStringInput
  and: [ModelAuthorFilterInput]
  or: [ModelAuthorFilterInput]
  not: ModelAuthorFilterInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

type Query {
  getAuthor(id: ID!): Author
  listAuthors(filter: ModelAuthorFilterInput, limit: Int, nextToken: String): ModelAuthorConnection
  getSurveys(id: ID!): Surveys
  listSurveys(filter: ModelSurveysFilterInput, limit: Int, nextToken: String): ModelSurveysConnection
  getUser(id: ID!): User
  listUsers(filter: ModelUserFilterInput, limit: Int, nextToken: String): ModelUserConnection
}

input CreateAuthorInput {
  id: ID
  name: String
  avatarUrl: String
  email: String
}

input UpdateAuthorInput {
  id: ID!
  name: String
  avatarUrl: String
  email: String
}

input DeleteAuthorInput {
  id: ID!
}

type Mutation {
  createAuthor(input: CreateAuthorInput!, condition: ModelAuthorConditionInput): Author
  updateAuthor(input: UpdateAuthorInput!, condition: ModelAuthorConditionInput): Author
  deleteAuthor(input: DeleteAuthorInput!, condition: ModelAuthorConditionInput): Author
  createSurveys(input: CreateSurveysInput!, condition: ModelSurveysConditionInput): Surveys
  updateSurveys(input: UpdateSurveysInput!, condition: ModelSurveysConditionInput): Surveys
  deleteSurveys(input: DeleteSurveysInput!, condition: ModelSurveysConditionInput): Surveys
  createSurveyUser(input: CreateSurveyUserInput!, condition: ModelSurveyUserConditionInput): SurveyUser
  updateSurveyUser(input: UpdateSurveyUserInput!, condition: ModelSurveyUserConditionInput): SurveyUser
  deleteSurveyUser(input: DeleteSurveyUserInput!, condition: ModelSurveyUserConditionInput): SurveyUser
  createUser(input: CreateUserInput!, condition: ModelUserConditionInput): User
  updateUser(input: UpdateUserInput!, condition: ModelUserConditionInput): User
  deleteUser(input: DeleteUserInput!, condition: ModelUserConditionInput): User
}

input ModelAuthorConditionInput {
  name: ModelStringInput
  avatarUrl: ModelStringInput
  email: ModelStringInput
  and: [ModelAuthorConditionInput]
  or: [ModelAuthorConditionInput]
  not: ModelAuthorConditionInput
}

type Subscription {
  onCreateAuthor: Author @aws_subscribe(mutations: ["createAuthor"])
  onUpdateAuthor: Author @aws_subscribe(mutations: ["updateAuthor"])
  onDeleteAuthor: Author @aws_subscribe(mutations: ["deleteAuthor"])
  onCreateSurveys: Surveys @aws_subscribe(mutations: ["createSurveys"])
  onUpdateSurveys: Surveys @aws_subscribe(mutations: ["updateSurveys"])
  onDeleteSurveys: Surveys @aws_subscribe(mutations: ["deleteSurveys"])
  onCreateSurveyUser: SurveyUser @aws_subscribe(mutations: ["createSurveyUser"])
  onUpdateSurveyUser: SurveyUser @aws_subscribe(mutations: ["updateSurveyUser"])
  onDeleteSurveyUser: SurveyUser @aws_subscribe(mutations: ["deleteSurveyUser"])
  onCreateUser(username: String!): User @aws_subscribe(mutations: ["createUser"])
  onUpdateUser(username: String!): User @aws_subscribe(mutations: ["updateUser"])
  onDeleteUser(username: String!): User @aws_subscribe(mutations: ["deleteUser"])
}

type ModelSurveysConnection {
  items: [Surveys]
  nextToken: String
}

input ModelSurveyStatusInput {
  eq: SurveyStatus
  ne: SurveyStatus
}

input ModelSurveysFilterInput {
  id: ModelIDInput
  title: ModelStringInput
  authorId: ModelIDInput
  surveyCreatedAt: ModelStringInput
  surveyUrl: ModelStringInput
  status: ModelSurveyStatusInput
  and: [ModelSurveysFilterInput]
  or: [ModelSurveysFilterInput]
  not: ModelSurveysFilterInput
}

input CreateSurveysInput {
  id: ID
  title: String
  authorId: ID!
  surveyCreatedAt: String
  surveyUrl: String
  status: SurveyStatus
}

input UpdateSurveysInput {
  id: ID!
  title: String
  authorId: ID
  surveyCreatedAt: String
  surveyUrl: String
  status: SurveyStatus
}

input DeleteSurveysInput {
  id: ID!
}

input ModelSurveysConditionInput {
  title: ModelStringInput
  authorId: ModelIDInput
  surveyCreatedAt: ModelStringInput
  surveyUrl: ModelStringInput
  status: ModelSurveyStatusInput
  and: [ModelSurveysConditionInput]
  or: [ModelSurveysConditionInput]
  not: ModelSurveysConditionInput
}

input CreateSurveyUserInput {
  id: ID
  surveyID: ID!
  participantID: ID!
}

input UpdateSurveyUserInput {
  id: ID!
  surveyID: ID
  participantID: ID
}

input DeleteSurveyUserInput {
  id: ID!
}

input ModelSurveyUserConditionInput {
  surveyID: ModelIDInput
  participantID: ModelIDInput
  and: [ModelSurveyUserConditionInput]
  or: [ModelSurveyUserConditionInput]
  not: ModelSurveyUserConditionInput
}

type ModelUserConnection {
  items: [User]
  nextToken: String
}

input ModelUserFilterInput {
  id: ModelIDInput
  username: ModelStringInput
  email: ModelStringInput
  and: [ModelUserFilterInput]
  or: [ModelUserFilterInput]
  not: ModelUserFilterInput
}

input CreateUserInput {
  id: ID
  username: String!
  email: String!
}

input UpdateUserInput {
  id: ID!
  username: String
  email: String
}

input DeleteUserInput {
  id: ID!
}

input ModelUserConditionInput {
  email: ModelStringInput
  and: [ModelUserConditionInput]
  or: [ModelUserConditionInput]
  not: ModelUserConditionInput
}

input ModelIDKeyConditionInput {
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  between: [ID]
  beginsWith: ID
}

type ModelSurveyUserConnection {
  items: [SurveyUser]
  nextToken: String
}

input ModelSurveyUserFilterInput {
  id: ModelIDInput
  surveyID: ModelIDInput
  participantID: ModelIDInput
  and: [ModelSurveyUserFilterInput]
  or: [ModelSurveyUserFilterInput]
  not: ModelSurveyUserFilterInput
}
